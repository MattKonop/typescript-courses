{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/course/enterprise-v2/05-converting-to-ts/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Learn TypeScript w/ Mike North","courses":[{"id":"fundamentals-v3","name":"TypeScript Fundamentals v3","summary":"Learn everything you need to know in order to confidently and successfully use TypeScript to build a modern JavaScript app."},{"id":"fundamentals-v4","name":"TypeScript Fundamentals v4","summary":"Learn everything you need to know in order to confidently and successfully use TypeScript to build a modern JavaScript app."},{"id":"intermediate-v1","name":"Intermediate TypeScript v1","summary":"Leverage TypeScript's strengths to provide clarity in the face of\ncomplexity, while protecting your codebase and team from it's weaknesses.\n"},{"id":"intermediate-v2","name":"Intermediate TypeScript v2","summary":"Leverage TypeScript's strengths to provide clarity in the face of\ncomplexity, while protecting your codebase and team from it's weaknesses.\n"},{"id":"making-typescript-stick","name":"Making TypeScript Stick","summary":"Tackle a series of challenges designed to reinforce your knowledge and make\nthe important concepts truly \"stick\" in your mind.\n"},{"id":"enterprise-v2","name":"Enterprise TypeScript v2","summary":"Combine TypeScript and GraphQL's type systems to create full-stack, fully\ntype-checked code bases that are shockingly easy to refactor and maintain.\n"},{"id":"full-stack-typescript","name":"Full Stack TypeScript","summary":"Combine TypeScript and GraphQL's type systems to create full-stack, fully\ntype-checked code bases that are shockingly easy to refactor and maintain.\n"}]}},"markdownRemark":{"id":"4e5f64ef-fde5-5b3b-aee8-16f8930952e3","excerpt":"Converting a large project to TypeScript can sometimes be daunting. It’s clear that the starting point is a bunch of JavaScript, totally lacking static types…","html":"<p>Converting a large project to TypeScript can sometimes be daunting. It’s clear that the starting point is a bunch of JavaScript, totally lacking static types, and in the end you want to have very specific types across the entire project and all of your dependencies, but jumping straight to that end point in one shot can be <em>very dangerous</em>. In this chapter, we’ll walk through a hands-on example together, demonstrating how a migration like this can be conducted on an <em>enterprise-scale</em> project.</p>\n<!-- markdownlint-disable-next-line MD026-->\n<h2 id=\"keep-in-mind\" style=\"position:relative;\"><a href=\"#keep-in-mind\" aria-label=\"keep in mind permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Keep in mind…</h2>\n<ul>\n<li><strong>Stay focused on carrying out specific tasks</strong>. It’s very easy to succumb to the temptation to do too much at a time. Don’t worry, we’ll get there, and if we stay well-organized, we’ll get there <em>safely and without incident</em></li>\n<li><strong>Make sure you have a solid test suite</strong>. It’s very easy to make a simple change (e.g. changing a <code>if (foo)</code> to <code>if (typeof foo === 'undefined')</code>) which can break your program in subtle ways</li>\n<li><strong>Don’t let the perfect be the enemy of the good</strong>. TypeScript was built to allow <a href=\"https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html#moving-to-typescript-files\">incremental adoption</a> — take advantage of it! The types we’ll be using early on in the process are <em>way less descriptive</em> than what we’ll want to end up with. That’s ok!</li>\n</ul>\n<h2 id=\"an-overview-of-the-approach\" style=\"position:relative;\"><a href=\"#an-overview-of-the-approach\" aria-label=\"an overview of the approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>An overview of the approach</h2>\n<p>Each of these steps should involve verifying that building and testing the program works, and a separate <code>git commit</code>.</p>\n<ol>\n<li><strong>Get TypeScript into your build toolchain</strong>, type-checking your existing <code>.js</code> files, in the most permissive mode possible</li>\n<li><strong>Rename some files from <code>.js</code> to <code>.ts</code></strong>, fixing only the things necessary to get the compile working</li>\n<li>\n<p><strong>Forbid implicit <code>any</code>s</strong>, replacing them throughout the codebase with <em>explicit <code>any</code>s</em>, <code>{}</code>s or more descriptive types</p>\n<ul>\n<li>Improve error handling by enabling <code>useUnknownInCatchVariables</code> in tsconfig</li>\n<li>Install community-supported types from <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/\">DefinitelyTyped</a> where necessary</li>\n</ul>\n</li>\n<li><strong>Start formalizing type information relating to your codebase</strong>. Make some <code>interface</code>s and <code>type</code> aliases.</li>\n<li>\n<p><strong>Add safety to boolean expressions, and improve handling of <code>null</code> and <code>undefined</code></strong></p>\n<ul>\n<li>Enable the ESLint rule <code>@typescript-eslint/strict-boolean-expressions</code> to catch problematic truthy/falsy expressions</li>\n<li>Enable the tsconfig option <code>strictNullChecks</code> to ensure that if <code>null</code> is desired to be an allowed value in a type, it has to be explicitly stated as such</li>\n<li>Enable the tsconfig option <code>exactOptionalPropertyTypes</code> to catch occurrences where optional properties are explicitly set to the value <code>undefined</code> instead of being deleted</li>\n</ul>\n</li>\n<li>\n<p><strong>Improve types for functions</strong> by doing the following</p>\n<ul>\n<li>\n<p>In <code>tsconfig.json</code></p>\n<ul>\n<li>Add safety around <code>Function</code> methods <code>bind</code>, <code>call</code> and <code>apply</code> by enabling <code>strictBindCallApply</code></li>\n<li>Add safety around <code>this</code> types by enabling <code>noImplicitThis</code></li>\n<li>Catch inappropriate <code>function</code> vs <code>function</code> type-checking by enabling <code>strictFunctionTypes</code></li>\n<li>Ensure all code branches within a function consistently return a value, or return no value by enabling <code>noImplicitReturns</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Improve typing around <code>class</code>es</strong></p>\n<ul>\n<li>\n<p>In <code>tsconfig.json</code></p>\n<ul>\n<li>Ensure class fields are initialized by the time instances are returned by constructors, by turning on <code>strictPropertyInitialization</code></li>\n<li>Start requiring use of the <code>override</code> keyword on methods that override a same-named method on a base class, by enabling <code>noImplicitOverride</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Start to get rid of explicit <code>any</code>s</strong> in some places. This is a BIG step, and should be done in smaller increments</p>\n<ul>\n<li>\n<p>In <code>.eslintrc.js</code></p>\n<ul>\n<li>Ensure functions don’t return an <code>any</code> or <code>any[]</code>, by enabling <code>@typescript-eslint/no-unsafe-return</code></li>\n<li>Ensure values of type <code>any</code> aren’t passed to functions functions by enabling <code>@typescript-eslint/no-unsafe-argument</code></li>\n<li>Ensure values of type <code>any</code> can’t be called (as a function) by enabling <code>@typescript-eslint/no-unsafe-calls</code></li>\n<li>These two rules are going object to a <em>lot</em> more things, relative to the other two in this group. Consider doing these steps in smaller chunks, each with their own commit</li>\n<li>Ensure that member access (grabbing a property) can’t be performed on values of type <code>any</code> by enabling <code>@typescript-eslint/no-unsafe-member-access</code></li>\n<li>Ensure variables can’t be assigned a value of type <code>any</code> or <code>any[]</code> by enabling <code>@typescript-eslint/no-unsafe-assignment</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Develop a clear distinction between access of known properties and “dictionary access”</strong></p>\n<ul>\n<li>Require that known properties must be accessed via <code>foo.bar</code> syntax, by enabling the tsconfig option <code>noPropertyAccessFromIndexSignature</code></li>\n<li>Require that “dictionary access” must be performed via <code>foo[\"bar\"]</code> syntax, and represent that any given dictionary value may be <code>undefined</code> by enabling the tsconfig option <code>noUncheckedIndexedAccess</code></li>\n</ul>\n</li>\n<li>\n<p><strong>Require an eslint-disable comment for all remaining explicit <code>any</code>s</strong></p>\n<ul>\n<li>Turn on the ESLint rule <code>@typescript-eslint/no-explicit-any</code></li>\n</ul>\n</li>\n<li>\n<p><strong>Remove or appropriately denote unused and unnecessary things</strong></p>\n<ul>\n<li>Turn on <code>noUnusedLocals</code> and <code>noUnusedParameters</code> in tsconfig, to catch unused variables and function parameters, respectively</li>\n<li>Turn on <code>@typescript-eslint/no-unnecessary-type-assertion</code> to catch places where the use of a type assertion isn’t necessary in order to narrow a type for downstream usage</li>\n<li>Turn on <code>@typescript-eslint/no-unnecessary-type-arguments</code> to catch places where an explicit typeParam is provided unnecessarily (meaning the same type would have been inferred)</li>\n<li>Turn on <code>@typescript-eslint/no-unnecessary-condition</code> to catch places where, as long as the types are correct, a condition will <em>always</em> be evaluated as either <code>true</code> or <code>false</code></li>\n<li>Turn on <code>@typescript-eslint/no-type-constraint</code> to catch places where type constraints are written in a way that doesn’t change the allowed values (e.g. <code>T extends any</code> is just <code>T</code>)</li>\n</ul>\n</li>\n</ol>\n<p>There are <a href=\"https://typescript-eslint.io/rules/\">a wide range of TypeScript ESLint rules</a> available, but not all of them are necessarily useful as part of the journey to add static types to a formerly un-typed codebase. In particular, I would avoid making <em>stylistic changes</em> (e.g. <a href=\"https://typescript-eslint.io/rules/naming-convention\">naming conventions for certain types of declarations</a>) during this conversion journey, as this is more perturbance of the codebase while it’s in a partially-typed state.</p>\n<p>We won’t go through every one of these steps together, as the whole point of this approach is that the work becomes quite methodical and predictable.</p>","tableOfContents":"<ul>\n<li><a href=\"#keep-in-mind\">Keep in mind…</a></li>\n<li><a href=\"#an-overview-of-the-approach\">An overview of the approach</a></li>\n</ul>","fields":{"slug":"/course/enterprise-v2/05-converting-to-ts/"},"frontmatter":{"title":"Converting to TypeScript","course":"enterprise-v2","date":"October 27, 2023","description":"We'll discuss the goals and agenda of this course, and how to get up and\nrunning with the workshop project in 2 minutes or less.\n"}}},"pageContext":{"slug":"/course/enterprise-v2/05-converting-to-ts/","title":"Converting to TypeScript","course":"enterprise-v2","order":5,"previous":{"fields":{"slug":"/course/enterprise-v2/04-app-vs-library-concerns/"},"frontmatter":{"title":"App vs Library Concerns","order":4,"course":"enterprise-v2","isExercise":null}},"next":{"fields":{"slug":"/course/enterprise-v2/06-steps-1-2-3/"},"frontmatter":{"title":"Steps 1, 2 and 3 - Adding our first types","order":6,"course":"enterprise-v2","isExercise":null}}}},
    "staticQueryHashes": ["2785745750","2841359383"]}